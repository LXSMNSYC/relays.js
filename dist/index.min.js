var Relay=function(){"use strict";const t=(t=>!!t&&("object"==typeof t||"function"==typeof t)&&"function"==typeof t.then)||result instanceof Promise,e=(...t)=>t;class n{constructor(t){this._processor="function"==typeof t?t:e,this._input=[],this._output=[],this._received=[]}connectTo(t){if(t instanceof n){const e=t._input,n=this._output;n.includes(t)||n.push(t),e.includes(this)||e.push(this)}return this}connectFrom(t){return t.connectTo(this),this}disconnectTo(t){if(t instanceof n){const e=t._input,n=this._output;n.includes(t)&&(this._output=n.filter(e=>e!==t)),e.includes(this)&&(t._input=e.filter(t=>t!==this))}return this}disconnectFrom(t){return t.disconnectTo(this),this}isConnectedTo(t){return t instanceof n&&this._output.includes(t)}isConnectedFrom(t){return t instanceof n&&this._input.includes(t)}isConnected(t){return this.isConnectedTo(t)||this.isConnectedFrom(t)}isConnectedBothways(t){return this.isConnected(t)&&t.isConnected(this)}receive(...e){const n=this._processor,i=(e.length,this._input),s=(this._output,t=>{for(const e of this._output)e.receive(t)}),o=e=>{let i;try{i=n.apply(null,e)}catch{return this}return t(i)?i.then(s):s(i),this},c=i.length;if(0==c)return o(e);for(this._received=[...this._received,...e];c<=this._received.length;){const t=this._received;o(t.slice(0,c)),this._received=t.slice(c)}return this}pass(t){return this.connectTo(new n(t))}}return n}();